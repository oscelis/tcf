% FUNCTION NAME:
%   tcf
%
% DESCRIPTION:
%   R = tcf(f, x) computes the tcf rational approximant R (function handle) to
%    data f on the sample points x. f may be given by its values at x,
%    or as a function handle.
%
%  [R, POL, ZER, RES] = tcf(f, x) returns vectors of poles, residues, and zeros of R.
%    
%  [R, POL, ZER, RES, PHIJ, XJ] = tcf(f, x) also returns the vectors of
%   interpolation points XJ and inverse differences PHIJ of the
%   Thiele continued fraction representation of R. 
%
%  [R, POL, ZER, RES, PHIJ, XJ, ERRVEC] = tcf(f, x) also returns the vector
%   of errors ||f-r||_infty in successive iterative steps of tcf. 
%
%  R = tcf(f, x, NAME, VALUE) sets the following parameters:
%    - 'tol', TOL: relative tolerance (default TOL = 1e-13),
%    - 'nmax', NMAX: maximal number of interpolation points used by tcf (default NMAX = 200), 
%    -'prz', 'off' or 0: turns off automatic calculation of poles, residues and zeroes
%    -'eqtm', 'on' or 1, turns on equivalence transformation for 
%                        more stable pole/zero calculations (default eqtm = 0)
%    -'bal', 'off' or 0 turns off automatic balancing [2] for pole/zero
%                       calculations (default bal = 1)
%
%Examples:
%   xx = linspace(-1,1); r = tcf(@exp,xx); plot(xx,r(xx)-exp(xx))
%
%   xx = linspace(-1,1); r = tcf(@exp,xx,'nmax',11); plot(xx,r(xx)-exp(xx))
%
%   Z = exp(2i*pi*linspace(0,1,500)); 
%   [r,pol] = tcf(@tan,Z); disp(pol)
%
% REFERENCE:
%   [1] Numerical Continued Fraction Interpolation. O. Salazar Celis
%   Ukranian Mathematical Journal 76:635–648, 2024.
%   [2] Balancing regular matrix pencils. D. Lemonnier and P. Van Dooren.  
%   SIAM Journal on Matrix Analysis and Applications, 28(1):253–263, 2006.

function [r,pol, zer, res, aa, zz, err, ss] = tcf(ff,xx, varargin)
% Parse inputs:
[ff, xx, nmax, tol, eqtm, prz, bal] = parseInputs(ff,xx, varargin{:});

xx = xx(:); ff= ff(:);
toKeep = ~isinf(ff) & ~isnan(ff);
ff = ff(toKeep); xx= xx(toKeep);

aa=nan(nmax,1); zz=nan(nmax,1); 
ss=ones(nmax,1); %coefs for equivalence transformation (1 by default)
err = nan(nmax,1);
       
abstol = tol*norm(ff, inf);   % Absolute tolerance

    for k=1:nmax %main loop
        if k==1 %init
            [~,i] = min(abs(ff)); %smallest value
            aa(k) = inv_diff_cfrac(aa,zz,ss,xx(i),ff(i)); %ss[1] = 1
        else
            [~,i]= max(abs(evalcfrac(aa,zz,ss,xx)-ff)); %adaptive choice
            aa(k) = inv_diff_cfrac(aa,zz,ss,xx(i),ff(i)); %ss(k-1) =1
            if eqtm==1 %apply equivalence transformation
                alpha = 1/2; 
                mindist = exp(-2*pi*sqrt(k)/sqrt(alpha));
                e = 1/(abs(aa(k-1)*aa(k))+mindist);
                ss(k-1) = pow2(1,round(log2(e)));
            end
            aa(k) = aa(k)*ss(k-1);
        end
        zz(k)= xx(i); %store cfrac coef
        err(k) = norm(evalcfrac(aa,zz,ss,xx)-ff, inf);
        ff(i) = [] ;%reduce data
        xx(i)=[]; 
        if k < nmax 
            if ( err(k) <= abstol )
                disp(['Target precision reached earlier at n=' num2str(k)]);
                break
            end
        end
    end
    aa = aa(~isnan(aa)); zz = zz(~isnan(zz));
    ss = ss(~isnan(aa));
    r = @(Z) evalcfrac(aa,zz,ss,Z);
    err = err(~isnan(err));
    pol = []; zer = []; res = [];
    if prz == 1, [pol,zer, res] = prz_cfrac(aa,zz,ss, bal); end
end

% FUNCTION NAME:
%   evalcfrac
%
% DESCRIPTION:
%   Backward evaluation of a continued fraction
%       aa1 + ss1*(x-zz1)/aa2+... 
%
%
% INPUT:
%   aa - (vector double) inverse differences
%   zz - (vector double) associated locations used
%   ss - (vector double) associated scalings used
%   x  - (vector double) location where to evaluate
%
%
% OUTPUT:
%   r - evaluation of continued fraction at x
%
%
% ASSUMPTIONS AND LIMITATIONS:
%   aa, zz and ss are generated by tcf
%
% See also tcf, prz_cfrac
function r = evalcfrac(aa,zz,ss,x)
%backward evaluation of continued fraction aa1 + (x-zz1)/aa2+...
    k = max(find(~isnan(aa), 1, 'last' ));
    xv = x(:);  % vectorize x if necessary
    r = zeros(length(xv),1);
    if k>1
        for i=k:-1:2
            r = ((ss(i-1).*xv-ss(i-1).*zz(i-1)))./(aa(i)+r);
        end
    end
    r = aa(1)+r;
    % Reshape to input format:
    r = reshape(r, size(x));
end


% FUNCTION NAME:
%   inv_diff_cfrac
%
% DESCRIPTION:
%   Backward evaluation of a continued fraction
%       aa1 + (x-zz1)/aa2+... 
%
%
% INPUT:
%   aa - (vector double) inverse differences
%   zz - (vector double) associated locations used
%   zz - (vector double) associated scalings used
%   x  - (double) location where to evaluate
%   f  - (double) value of f(x) to interpolate
%
%
% OUTPUT:
%   r - evaluation of continued fraction at x
%
%
% ASSUMPTIONS AND LIMITATIONS:
%   aa, zz and ss are generated by cfrac_interpolate
%
%
% See also tcf, prz_cfrac
function r = inv_diff_cfrac(aa,zz,ss,x,f)
%backward evaluation of continued fraction for inverse differences
    k = max(find(~isnan(aa), 1, 'last' ));
    r = f;
    if k>0
        for i=1:k
            r = ((ss(i)*x-ss(i)*zz(i)))./(-aa(i)+r);
        end
    end
end

% FUNCTION NAME:
%   prz_cfrac
%
% DESCRIPTION:
%   Returns poles, residues and zeros of a continued fraction 
%       aa1 + (x-zz1)/aa2+... 
%
%
% INPUT:
%   aa - (vector double) inverse differences
%   zz - (vector double) associated locations used
%
%
% OUTPUT:
%   pol - poles
%   zer - zeros
%   res - residues
%
%
% ASSUMPTIONS AND LIMITATIONS:
%   aa, zz and ss are generated by tcf
%
%
% See also tcf, evalcfrac
function [pol,zer, res] = prz_cfrac(aa,zz,ss, bal)
    k   = max(find(~isnan(aa), 1, 'last' ));
    C   = -diag(ss(2:(k-1)),1);
    Dp  = diag(aa(2:k))-diag(ss(2:(k-1)).*zz(2:(k-1)),1)-diag(ones(k-2,1),-1);
    if (bal==0)
        pol = eig(Dp,C); pol = pol(~isinf(pol)); %poles
    else
     [Dl, Dr, iter] = baleig(Dp,C,5);%scaling
     T1 = diag(1./Dl); T2 = diag(Dr);
     pol = eig(T1*Dp*T2,T1*C*T2); pol = pol(~isinf(pol)); %poles
    end

    C   = -diag(ss(1:(k-1)),1);
    Dz  = diag(aa(1:k))-diag(ss(1:(k-1)).*zz(1:(k-1)),1)-diag(ones(k-1,1),-1);
    if (bal==0)
       zer = eig(Dz,C); zer = zer(~isinf(zer)); %zeros
    else
        [Dl, Dr, iter] = baleig(Dz,C,5);
        T1 = diag(1./Dl); T2 = diag(Dr);
        zer = eig(T1*Dz*T2,T1*C*T2); zer = zer(~isinf(zer)); %zeros
    end

    res = nan(length(pol),1);
    dz = 1e-5*exp(2i*pi*(1:4)/4);
    pz = bsxfun(@plus,pol,dz);
    for k = 1:length(pol)
        res(k)=(evalcfrac(aa,zz, ss, pz(k,:).').')*(dz.')/4;
    end
end

function [Dl, Dr, iter] = baleig(A,B,max_iter)
% Performs two-sided scaling Dl\A*Dr, Dl\B*Dr in order to improve
% the sensitivity of generalized eigenvalues. The diagonal matrices
% Dl and Dr are constrained to powers of 2 and are computed iteratively
% until the number of iterations max_iter is met or until the norms are
% between 1/2 and 2. Convergence is often reached after 2 or 3 steps.
% The diagonals of the scaling matrices are returned in Dl and Dr
% and so is iter, the number of iterations steps used by the method.
n=size(A,1); Dl=ones(1,n); Dr=ones(1,n); M=abs(A).^2+abs(B).^2;
for iter=1:max_iter,
    emax=0;emin=0;
    for i=1:n;
        % scale the rows of M to have approximate row sum 1
        d=sum(M(i,:));e=-round(log2(abs(d))/2);
        M(i,:)=pow2(M(i,:),2*e);
        % apply the square root scaling also to A, B and Dl
        Dl(i)=pow2(Dl(i),-e);
        if e > emax, emax=e; end; if e < emin, emin=e; end
    end
    for i=1:n;
        % scale the columns of M to have approximate column sum 1
        d=sum(M(:,i));e=-round(log2(abs(d))/2);
        M(:,i)=pow2(M(:,i),2*e);
        % apply the square root scaling also to A, B and Dr
        Dr(i)=pow2(Dr(i),e);
        if e > emax, emax=e; end; if e < emin, emin=e; end
    end
    % Stop if norms are all between 1/2 and 2
    if (emax<=emin+2), break; end
end
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   PARSEINPUTS   %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [ff, xx, nmax, tol, eqtm, prz, bal] = parseInputs(ff,xx, varargin)

% Check if ff is empty:
if ( isempty(ff) )
    error('tcf:emptyF', 'No function given.')
end
% Check if xx is empty:
if ( isempty(ff) )
    error('tcf:emptyX', 'No points given.')
end

if isa(ff, 'function_handle'), ff = ff(xx); end
tol = 1e-13;    %default tol
prz = 1;        %return poles or not?
nmax = min(length(xx),200); %default number of points to use maximun
eqtm = 0;       %equivalence transformation? 0 = off (default), 1 = on
bal = 1; %use balancing for pole/zero calculation 0 = off, 1 = 0 (default)

while ( ~isempty(varargin) )   % Check if parameters have been provided
    if ( strncmpi(varargin{1}, 'tol', 3) )
        if ( isfloat(varargin{2}) && isequal(size(varargin{2}), [1, 1]) )
            tol = varargin{2};
        end
        varargin([1, 2]) = [];

    elseif ( strncmpi(varargin{1}, 'nmax', 4) )
        if ( isfloat(varargin{2}) && isequal(size(varargin{2}), [1, 1]) )            
            nmax = min(length(xx),varargin{2});
        end
        varargin([1, 2]) = []; 
    
    elseif ( strncmpi(varargin{1}, 'eqtm', 4) )
        if ( strncmpi(varargin{2}, 'on', 2) || ( varargin{2} == 1 ) )
            eqtm = 1;
        end
        varargin([1, 2]) = [];
    
    elseif ( strncmpi(varargin{1}, 'prz', 3) )
        if  ( ( varargin{2} == 0 )|| ( varargin{2} == 1 ) )
            prz = varargin{2};
        end
        varargin([1, 2]) = [];

    elseif ( strncmpi(varargin{1}, 'bal', 3) )
        if ( strncmpi(varargin{2}, 'off', 2) || ( varargin{2} == 0 ) )
            bal = 0;
        end
        varargin([1, 2]) = [];
    else
        error('tcf:UnknownArg', 'Argument unknown.')
    end
end
end



